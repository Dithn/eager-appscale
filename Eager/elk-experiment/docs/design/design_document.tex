\documentclass[11pt]{article}
\usepackage{graphicx}
\DeclareGraphicsExtensions{.png,.jpg}
\graphicspath{{./figures/}}

\begin{document}

\title{Architecture of the Proposed Cloud Application Platform Monitor}
\author{Chandra Krintz, Rich Wolski, Hiranya Jayathilaka, Wei-Tsung Lin}
\maketitle

\section{Introduction}
Over the last decade Platform-as-a-Service (PaaS) has become a popular approach for deploying
applications in the cloud. Many organizations, academic institutes and hobbyists make use of public
and/or private PaaS clouds to deploy their applications.
PaaS clouds provide a high level of abstraction to the application developer that effectively hides
all the infrastructure-level details such as physical resource allocation (CPU, memory, disk etc), operating
system configuration, 
and network set up. This enables application developers to focus solely on the programming
aspects of their applications, without having to be concerned about deployment issues. PaaS
clouds can also ensure high levels of scalability and availability for the deployed applications. 
Scalability is typically provided by automatically allocating resources for applications
on the fly (auto scaling), and availability is ensured by running multiple instances of the application.
Consequently the viable PaaS technologies, and the PaaS-deployed applications
continue to increase in number.

This rapid growth in PaaS technology has intensified the need for new techniques to
monitor applications deployed in a PaaS cloud. Application developers and users wish
to monitor the availability of the deployed applications, track application performance and detect 
application and system anomalies as they occur. To obtain this level of deep operational insight into
PaaS-deployed applications, the PaaS clouds need to be equipped with powerful instrumentation,
data gathering and analysis capabilities that span the entire stack of the PaaS cloud. 
Moreover, PaaS clouds need to provide comprehensive
data visualization and notification mechanisms. However, most PaaS technologies available
today either do not provide any application monitoring support, or only provide primitive
monitoring features such as application-level logging. Hence, they are not capable of performing
powerful predictive analyses or anomaly detection, which require much more fine-grained, low-level
and full stack data collection and analytics. 

To address this limitation we intend to design and implement a comprehensive application platform 
monitor (APM) that can be easily integrated with a wide variety of PaaS technologies. The proposed
APM is not an external system that monitors a PaaS cloud from the outside. Rather, it integrates with
the PaaS cloud from within thereby extending and augmenting the existing components of the PaaS cloud
to provide comprehensive full stack monitoring, analytics and visualization capabilities. In other words,
the APM is built into the PaaS cloud so that it is active as long as the cloud is, and has operational
insight to both core cloud components as well as the deployed applications.

This document details the architecture of the proposed APM, and how it integrates with a typical PaaS
cloud. We describe individual components of the APM, their functions and how they interact with each
other. Where appropriate we also detail the concrete technologies (tools and products) used to implement
various components of the APM, and give rationale for choosing those technologies.

We start by describing the layered system organization typically seen in PaaS clouds. Then we describe
the APM architecture, and show how it fits into the PaaS.

\section{PaaS System Organization}
\begin{figure}
\centering
\includegraphics[scale=0.5]{paas_architecture}
\caption{PaaS system organization.}
\label{fig:paas_architecture}
\end{figure}

Figure~\ref{fig:paas_architecture} shows the key system layers of a typical PaaS cloud. Arrows indicate
the flow of data and control in response to application requests.

At the lowest level of a PaaS cloud is an infrastructure that consists of the necessary compute, storage
and networking resources. How this infrastructure is set up may vary from a simple cluster of physical 
machines to a comprehensive Infrastructure-as-a-Service (IaaS) solution. In large scale PaaS clouds,
this layer typically consists of many virtual machines and/or containers with the ability to acquire more
resources on the fly.

On top of the infrastructure layer lies the PaaS kernel. This is a collection of managed, scalable
services that high-level application developers can compose into their applications. The provided services
may include database services, caching services, queueing services and much more. Some PaaS clouds
provide a managed set of APIs (an SDK) for the application developer to access these fundamental services. 
In that case all interactions between the applications and the PaaS kernel must take place through
the cloud provider specified APIs (e.g. Google App Engine). 

One level above the PaaS kernel we find the application servers that are used to deploy and run
applications. Application servers provide the necessary integration (linkage) between application code and the
underlying PaaS kernel, while sandboxing application code for secure, multi-tenant operation. On top
of the application servers layer resides the fronted and load balancing layer. This layer is responsible
for receiving all application requests, filtering them and routing them to an appropriate application
server instance for further execution. As the fronted server, it is the entry point for PaaS-deployed
applications for all application clients.

\section{Cloud APM Architecture}
\subsection{Key Functions}
\begin{figure}
\centering
\includegraphics[scale=0.5]{apm_functions}
\caption{Key functions of the APM.}
\label{fig:apm_functions}
\end{figure}

\begin{figure}
\centering
\includegraphics[scale=0.5]{apm_layout}
\caption{Deployment view of the APM functions.}
\label{fig:apm_layout}
\end{figure}

Like most system monitoring solutions, the proposed cloud APM needs to serve four major functions: Data
collection, storage, processing (analytics) and visualization. Figure~\ref{fig:apm_functions} shows the
logical organization of these functions in the APM, and various tasks that fall under each of them.
Figure~\ref{fig:apm_layout} shows a physical deployment view of the said functions. Arrows indicate
the flow of information through the APM.

Data collection is performed by various sensors and agents that instrument the applications and the
core components of the PaaS cloud. While sensors are very primitive in their capability to monitor
a given component, an agent may intelligently adapt to changing conditions, making decisions on
what information to capture and how often. Instrumentations should be lightweight and as non-intrusive
as possible so their existence does not put any additional overhead on the applications.

Data storage components should be capable of
dealing with potentially very high volumes of data. The data needs to be organized and indexed
to facilitate efficient retrieval, and replicated to maintain reliability and high availability. 

Data processing components should also be capable of processing large volumes of data in near real-time,
while supporting a wide range of data analytics features such as filters, projections and aggregations. 
They will employ various statistical and perhaps even machine learning methods to understand the
data, detect anomalies and identify bottlenecks in the system.

Data visualization layer mainly consists of graphical interfaces (dashboards) for displaying various
metrics computed by the data processing components. Additionally it may also have APIs to export
the calculated results and trigger alerts. 

\subsection{APM Architecture and Integration with PaaS}
\begin{figure}
\centering
\includegraphics[scale=0.35]{apm_architecture}
\caption{APM architecture.}
\label{fig:apm_architecture}
\end{figure}

Figure~\ref{fig:apm_architecture} illustrates the overall architecture of the proposed APM, and how 
it fits into the PaaS cloud stack. APM components are shown in grey, with their interactions indicated
by the black lines. The small grey boxes attached to the PaaS components represent the sensors and
agents used to instrument the cloud platform for data collection purposes. Note that the APM collects
data from all layers in the PaaS stack (i.e. full stack monitoring).

From the frontend and load balancing layer we gather all information related to incoming application
requests. A big part of this is scraping the HTTP server access logs, which indicate request timestamps,
source and destination addressing information, response time (latency) and other HTTP message
parameters. This information is readily available for harvesting in most technologies used as frontend
servers (e.g. Apache HTTPD, Nginx). Additionally we may also collect information pertaining to active
connections, invalid access attempts and other errors.

From the application server layer we intend to collect basic application logs as well as any other logs and 
metrics that can be easily collected from the application runtime. This may include some process level
metrics indicating the resource usage of the individual application instances. If deeper insight into the 
application execution becomes necessary, more intrusive instrumentation can be introduced to the 
application server (perhaps selectively or adaptively). 

At the PaaS kernel layer we employ instrumentation to record information regarding all kernel invocations
made by the applications. This instrumentation needs to be applied carefully as to not introduce a noticeable
overhead to the application execution. For each PaaS kernel invocation, we can capture the 
following parameters.
\begin{itemize}
\item Source application making the kernel invocation
\item Timestamp
\item Target kernel service and operation
\item Execution time of the invocation
\item Request size, hash and other parameters
\end{itemize}
Collecting this PaaS kernel invocation details enables tracing the execution of application 
requests, without the need for instrumenting application code, which we believe is a feature 
unique to PaaS clouds. 

Finally, at the lowest infrastructure level, we can collect information related to virtual machines, containers
and their resource usage. We can also gather metrics on network usage by individual components which
might be useful in a number of traffic engineering use cases. Where appropriate we can also scrape
hypervisor and container manager logs to get an idea of how resources are allocated and released over
time.

\subsection{Cross-layer Data Correlation}
Previous subsection details how the APM collects useful monitoring data at each layer of the cloud
stack. To make most out of the gathered data, and use them to perform complex analyses, we need
to be able to correlate data records collected at different layers of the PaaS. For example consider
the execution of a single application request. This single event results in following data records at
different layers of the cloud, which will be collected and stored by the APM as separate entities.

\begin{itemize}
\item A frontend server access log entry
\item An application server log entry
\item Zero or more application log entries
\item Zero or more PaaS kernel invocation records
\end{itemize}

We need a mechanism to tie these disparate records together, so the data processing layer can easily
aggregate the related information. For instance, we need to be able to retrieve via an
aggregation query, all PaaS kernel invocations made by a specific application request.

To facilitate this requirement we propose that frontend server tags all incoming application requests 
with unique identifiers.
This request identifier can be attached to HTTP requests as a header which is visible to all components 
internal to the PaaS cloud. All data collecting agents can then be configured to record the request identifiers
whenever recording an event. At the data processing layer APM can aggregate the data by request identifiers
to efficiently group the related records.

\section{Implementation}
\begin{figure}
\centering
\includegraphics[scale=0.5]{apm_impl}
\caption{APM implementation based on ElasticSearch.}
\label{fig:apm_impl}
\end{figure}
In this section we outline some of the technologies and tools that we have chosen to implement the proposed
APM architecture.  After a thorough evaluation of numerous existing system monitoring tools and platforms, 
we have decided to implement our APM for PaaS clouds using ElasticSearch. More specifically, ElasticSearch
will operate as the primary data storage component of the APM. ElasticSearch is ideal for storing large volumes
of structured and semi-structured data. It supports scalability and high availability via sharding and replication.
Perhaps what makes ElasticSearch an excellent choice for an APM is its comprehensive data indexing and
query support. Using the tried and tested Apache Lucene technology, ElasticSearch continuously organizes
and indexes data, making the information available for fast retrieval and efficient querying. 
Additionally it also provides
powerful data filtering and aggregation features, which can greatly simplify the implementations of high-level
data processing algorithms.

Data can be directly stored in ElasticSearch via its REST API. This means most data collection agents can 
simply make HTTP calls to ElasticSearch to add new records. ElasticSearch also supports batch 
processing thereby enabling agents to locally buffer collected data, and store them in batches to avoid
making too many HTTP calls. For scraping server logs and storing the extracted records in ElasticSearch,
we can use the Logstash tool. Logstash supports scraping a wide range of standard log formats (e.g. 
Apache HTTPD access logs), and other custom log formats can be supported via a simple configuration.
It also integrates naturally with ElasticSearch.

For data visualization we are currently considering Kibana, a powerful web-based dash boarding tool 
that is specifically designed to operate in conjunction with ElasticSearch. Kibana provides a wide
range of charting and tabulation capabilities, with particularly strong support for temporal data.  Since
ElasticSearch exposes all stored data via its REST API, it's also possible to bring other visualization
tools into the mix easily.

Figure~\ref{fig:apm_impl} shows the APM deployment view with ElasticSearch and other related technologies
in place. Most of the data processing features are provided by ElasticSearch itself, and other more complex
data analytics can be provided by a custom data processing system. 

\section{APM Use Cases}
\subsection{Static Topology Discovery and SLA Prediction}
Our goal is to give a prediction that can make it possible to determine response time service level agreements(SLAs)
with probabilities specified by the cloud provider in a way that is scalable. To allow PaaS administrators to
determine what minimum response time guarantee can be made, we will take an approach which combines static analysis
of the hosted web APIs and runtime monitoring of the PaaS cloud.

One of the characteristic of PaaS systems that we are going to exploit is its predefined programming interfaces provided
by cloud SDK. Typically, PaaS-hosted web APIs perform one or more cloud SDK calls. From experience, we know that most APIs
spend majority of the execution time on cloud SDK invocations, and they do not have many branches and loops. Therefore,
we can use static analysis to identify these invocations. Also, since we want to provide the prediction to PaaS users when
they are deploying the applications, such static analysis needs to be done without deploying or running on PaaS cloud. 

To build a system that predicts response time SLAs using only static information, our design has three components:
\begin{itemize}
\item Static analysis tool
\item Monitoring agent
\item SLA predictor
\end{itemize}

\subsubsection{Static Analysis Tool}
This component analyzes the source code of the web API and extracts a sequence of cloud SDK operations. It performs a simple
construction and interprocedural static analysis of control flow graph for each web API operation. Ideally, we can identify cloud SDK
calls by their namespace.
Although loops are rare, when they occur, they are used to iterate over a dataset returned from a database. The tool estimates the loop 
bounds if specified in the cloud SDK call (e.g. the maximum number of entities to return).

\subsubsection{Monitoring Agent}
This agent monitors and records the response time of individual cloud SDK operations within a running PaaS system. It can be built as
a native PaaS feature, or as an independent application deployed on PaaS. To avoid unnecessary performance overhead on other PaaS-hosted
web APIs, the monitoring agent runs in the background separate from them.
The agent invokes cloud SDK operations periodically and records response times for each cloud SDK operation. Also, the agent periodically
reclaims old measurement data to eliminate unnecessary storage.

\subsubsection{SLA predictor}
The SLA predictor uses the outputs of other two components to predict an upper bound on the response time of the web API.
To make SLA predictions, we use a non-parametric time series analysis method in our design.

\subsubsection{Workflow}
The SLA prediction can be invoked when a web API is deployed to the PaaS cloud or at any time during the development process to give
developers insight into the worst-case response time of their applications.

When the prediction is invoked, it performs static analysis on all operations in the API. Next, it retrives benchmarking data from
the monitoring agent for all SDK operations. Finally, the non-parametric time series analysis method was applied to the data.

\section{Conclusions}
As the PaaS technologies become popular, the need for technologies to monitor the performance and behavior of
deployed applications has also grown. However, most PaaS clouds available today do not provide adequate
data collecting and analyzing tools. Therefore, we propose an application platform monitor system which can be
integrated to typical PaaS clouds.

To provide comprehensive full stack monitoring and analytics, the proposed APM needs to provide four major functions:
data collecting, data storage, data processing, and data visualization. We first show its organization of
these functions, and illustrate how these functions work as a component in the system. Also, by providing the
architecture of typical PaaS and proposed APM, we illustrate how these functions can be built as components that
make APM can be easily integrated with PaaS.

After investigating into some most used data collecting and analyzing tools, we choose ElasticSearch as data storage
component. ElasticSearch provides powerful, easy to use indexing features and scalability. We also decide to
implement the data collecting component by using logstash. Logstash supports a variety of standard log formants,
and is easy to be configured to collect custom data.

\end{document}