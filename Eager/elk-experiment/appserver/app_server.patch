diff --git a/AppServer_Java/src/com/google/appengine/tools/development/ApiProxyLocalImpl.java b/AppServer_Java/src/com/google/appengine/tools/development/ApiProxyLocalImpl.java
index 1a15112..844ea31 100644
--- a/AppServer_Java/src/com/google/appengine/tools/development/ApiProxyLocalImpl.java
+++ b/AppServer_Java/src/com/google/appengine/tools/development/ApiProxyLocalImpl.java
@@ -32,6 +32,26 @@ import com.google.apphosting.api.ApiProxy.Environment;
 import com.google.apphosting.api.ApiProxy.LogRecord;
 import com.google.apphosting.api.ApiProxy.UnknownException;
 
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadFactory;
+import java.util.Properties;
+import java.io.InputStream;
+import java.io.FileInputStream;
+import java.io.OutputStreamWriter;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import com.google.appengine.repackaged.org.apache.commons.httpclient.HttpClient;
+import com.google.appengine.repackaged.org.apache.commons.httpclient.methods.PostMethod;
+import com.google.appengine.repackaged.org.apache.commons.httpclient.methods.ByteArrayRequestEntity;
+import com.google.gson.Gson;
+
 /**
  * Implements ApiProxy.Delegate such that the requests are dispatched to local
  * service implementations. Used for both the
@@ -57,6 +77,145 @@ class ApiProxyLocalImpl implements ApiProxyLocal {
     private final LocalServiceContext context;
     private Clock clock = Clock.DEFAULT;
 
+    private final BlockingQueue<ApiCallEvent> pendingEvents = new LinkedBlockingQueue<ApiCallEvent>();
+    private final ExecutorService exec = Executors.newSingleThreadExecutor(new ThreadFactory() {
+        @Override
+        public Thread newThread(Runnable r) {
+            Thread t = new Thread(r, "api-call-event-reporter");
+            t.setDaemon(true);
+            return t;
+        }
+    });
+    private final String elasticSearchUrl;
+
+
+    private static class ApiCallEvent {
+        
+        private static final Gson gson = new Gson();
+        
+        private final long requestTimestamp;
+        private final String requestOperation;
+        private final long timestamp;
+        private final int sequenceNumber;
+        private final String requestId;
+        private final String appId;
+        private final String service;
+        private final String operation;
+        private final byte[] requestBytes;
+        private Object requestObject;
+        private long endTime = -1L;
+
+        public ApiCallEvent(Environment environment, long timestamp, String service, 
+                            String operation, byte[] requestBytes) {
+            this.requestTimestamp = (long) environment.getAttributes().get("edu.ucsb.cs.eager.RequestTimestamp");
+            this.requestOperation = (String) environment.getAttributes().get("edu.ucsb.cs.eager.RequestOperation");
+            this.requestId = (String) environment.getAttributes().get("edu.ucsb.cs.eager.RequestId");
+            if (environment instanceof LocalHttpRequestEnvironment) {
+              this.sequenceNumber = ((LocalHttpRequestEnvironment) environment).getApiCallNumber();
+            } else {
+              this.sequenceNumber = 0;
+            }
+            this.appId = ((LocalEnvironment) environment).getAppId();
+            this.timestamp = timestamp;
+            this.service = service;
+            this.operation = operation;
+            this.requestBytes = requestBytes;
+        }
+
+        public void setRequestObject(Object requestObject) {
+            this.requestObject = requestObject;
+        }
+
+        public void setEndTime(long endTime) {
+            this.endTime = endTime;
+        }
+
+        @Override
+        public String toString() {
+            Map<String,Object> event = new HashMap<>();
+            event.put("requestTimestamp", requestTimestamp);
+            event.put("requestOperation", requestOperation);
+            event.put("sequenceNumber", sequenceNumber);
+            event.put("timestamp", timestamp);
+            event.put("requestId", requestId);
+            event.put("appId", appId);
+            event.put("service", service);
+            event.put("operation", operation);
+            if (requestBytes != null) {
+                event.put("requestSize", requestBytes.length);
+                event.put("requestHash", Arrays.hashCode(requestBytes));
+            }
+            if (requestObject != null) {
+                event.put("requestType", requestObject.getClass().getName());
+            }
+            if (endTime > 0) {
+                event.put("elapsed", endTime - timestamp);
+            }
+            return gson.toJson(event);
+        }
+    }
+
+    private class ApiCallEventReporter implements Runnable {
+        @Override
+        public void run() {
+            List<ApiCallEvent> buffer = new ArrayList<>();
+            while (true) {
+                try {
+                    if (drain(buffer, 100, 10, TimeUnit.SECONDS) == 0) {
+                        continue;
+                    }
+
+                    if (elasticSearchUrl != null) {
+                      StringBuilder sb = new StringBuilder();
+                      for (ApiCallEvent e : buffer) {
+                          sb.append("\n{\"index\" : {\"_type\":\"" + e.appId + "\"}}");
+                          sb.append("\n").append(e.toString());
+                      }
+                      sb.append("\n");
+                      reportToElasticSearch(sb);
+                    }
+                    buffer.clear();
+                } catch (Exception ignored) {
+                }
+            }
+        }
+
+        private int drain(List<ApiCallEvent> buffer, int numElements, long timeout, TimeUnit unit) throws InterruptedException {
+            long deadline = System.nanoTime() + unit.toNanos(timeout);
+            int added = 0;
+            while (added < numElements) {
+                added += pendingEvents.drainTo(buffer, numElements - added);
+                if (added < numElements) { // not enough elements immediately available; will have to poll
+                    ApiCallEvent e = pendingEvents.poll(deadline - System.nanoTime(), TimeUnit.NANOSECONDS);
+                    if (e == null) {
+                        break; // we already waited enough, and there are no more elements in sight
+                    }
+                    buffer.add(e);
+                    added++;
+                }
+            }
+            return added;
+        }
+    }
+
+    private void reportToElasticSearch(StringBuilder sb) {
+        HttpClient client = new HttpClient();
+        PostMethod method = new PostMethod(elasticSearchUrl + "/_bulk");
+        method.setRequestEntity(new ByteArrayRequestEntity(sb.toString().getBytes(), "application/x-www-form-urlencoded"));
+        try {
+            int status = client.executeMethod(method);
+            String response = method.getResponseBodyAsString();
+            if (status != 200) {
+                logger.log(Level.WARNING, response);
+            }
+        } catch (Exception e) {
+            logger.log(Level.WARNING, "Error while reporting to ElasticSearch", e);
+        } finally {
+	    method.releaseConnection();
+        }
+    }
+
+
     /**
      * Creates the local proxy in a given context
      * 
@@ -65,6 +224,23 @@ class ApiProxyLocalImpl implements ApiProxyLocal {
      */
     protected ApiProxyLocalImpl(LocalServerEnvironment environment) {
         this.context = new LocalServiceContextImpl(environment);
+        this.exec.submit(new ApiCallEventReporter());
+        Properties esProps = new Properties();
+        FileInputStream in = null;
+        try {
+            in = new FileInputStream("/etc/appscale/elasticsearch.properties");
+            esProps.load(in);
+        } catch (IOException e) {
+            logger.log(Level.WARNING, "Failed to load ElasticSearch config", e);
+        } finally {
+            if (in != null) {
+                try {
+                    in.close();
+                } catch (IOException ignored) {
+                }
+            }
+        }
+        this.elasticSearchUrl = esProps.getProperty("url");
     }
 
     public void log(Environment environment, LogRecord record) {
@@ -93,8 +269,27 @@ class ApiProxyLocalImpl implements ApiProxyLocal {
         }
     }
 
+
+    private synchronized void writeToFile(String text) {
+        FileOutputStream fos = null;
+        try {
+            fos = new FileOutputStream("/root/hkj_appscale_test.log", true);
+            fos.write((text + "\n").getBytes());
+            fos.flush();
+        } catch (IOException ignored) {
+        } finally {
+            if (fos != null) {
+                try {
+                    fos.close();
+                } catch (IOException ignored) {
+                }
+            }
+        }
+    }
+
     public Future<byte[]> makeAsyncCall(Environment environment, String packageName, String methodName,
             byte[] requestBytes, ApiConfig apiConfig) {
+
         Semaphore semaphore = (Semaphore) environment.getAttributes().get(LocalEnvironment.API_CALL_SEMAPHORE);
 
         if (semaphore != null) {
@@ -307,14 +502,19 @@ class ApiProxyLocalImpl implements ApiProxyLocal {
         }
 
         public byte[] call() {
+            long start = System.currentTimeMillis();
+            ApiCallEvent event = new ApiCallEvent(environment, start, this.packageName, this.methodName, this.requestBytes);
             try {
-                return callInternal();
+                return callInternal(event);
             } finally {
                 tryReleaseSemaphore();
+                event.setEndTime(System.currentTimeMillis());
+                pendingEvents.offer(event);
             }
         }
 
-        private byte[] callInternal() {
+        private byte[] callInternal(ApiCallEvent event) {
+
             LocalRpcService service = getService(this.packageName);
 
             if (service == null) {
@@ -332,6 +532,7 @@ class ApiProxyLocalImpl implements ApiProxyLocal {
             try {
                 Class<?> requestClass = method.getParameterTypes()[1];
                 Object request = convertBytesToPb(this.requestBytes, requestClass);
+                event.setRequestObject(request);
 
                 return convertPbToBytes(method.invoke(service, new Object[] { status, request }));
             } catch (IllegalAccessException e) {
diff --git a/AppServer_Java/src/com/google/appengine/tools/development/LocalHttpRequestEnvironment.java b/AppServer_Java/src/com/google/appengine/tools/development/LocalHttpRequestEnvironment.java
index 13d3b92..96c9894 100644
--- a/AppServer_Java/src/com/google/appengine/tools/development/LocalHttpRequestEnvironment.java
+++ b/AppServer_Java/src/com/google/appengine/tools/development/LocalHttpRequestEnvironment.java
@@ -12,6 +12,8 @@ import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.UUID;
+import java.util.concurrent.atomic.AtomicInteger;
 
 public class LocalHttpRequestEnvironment extends LocalEnvironment
 {
@@ -34,6 +36,8 @@ public class LocalHttpRequestEnvironment extends LocalEnvironment
     private String                                    DEVEL_FAKE_IS_ADMIN_RAW_HEADER = "X-AppEngine-Fake-Is-Admin";
     private String                                    DEVEL_PAYLOAD_RAW_HEADER = "HTTP_X_APPENGINE_DEVELOPMENT_PAYLOAD";
 
+    private final AtomicInteger apiCallCounter = new AtomicInteger(0);
+
      public LocalHttpRequestEnvironment(String appId, String serverName, String majorVersionId, int instance, HttpServletRequest request, Long deadlineMillis, ServersFilterHelper serversFilterHelper)
      {
         super(appId, majorVersionId, deadlineMillis);
@@ -60,6 +64,14 @@ public class LocalHttpRequestEnvironment extends LocalEnvironment
             this.attributes.put("com.google.appengine.request.offline", Boolean.TRUE);
         }
 
+        String requestId = request.getHeader("X-Request-Id");
+        if (requestId == null) {
+          requestId = "autogen:" + UUID.randomUUID().toString();
+        }
+        this.attributes.put("edu.ucsb.cs.eager.RequestId", requestId);
+        this.attributes.put("edu.ucsb.cs.eager.RequestTimestamp", System.currentTimeMillis());
+        this.attributes.put("edu.ucsb.cs.eager.RequestOperation", request.getMethod() + " /foo");
+
         // AppScale: The metadata parameter is set in the Blobstore server before a blob upload callback request.
         String metadata = request.getParameter("blob_info_metadata");
         if(request.getParameter("blob_info_metadata") != null) {
@@ -92,6 +104,10 @@ public class LocalHttpRequestEnvironment extends LocalEnvironment
         this.attributes.put("com.google.appengine.tools.development.servers_filter_helper", serversFilterHelper);
     }
 
+    public int getApiCallNumber() {
+        return apiCallCounter.incrementAndGet();
+    }
+
     public boolean isLoggedIn()
     {
         if(this.FORCE_ADMIN)
