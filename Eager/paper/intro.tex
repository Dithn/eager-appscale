The growth of the World Wide Web (WWW), web services, and cloud computing have
significantly influenced the way developers implement software applications.
Instead of implementing all the functionality from the scratch, developers
increasingly offload as much application functionality as possible to remote,
web-accessible application programming interfaces (web APIs) hosted ``in the
cloud'', thereby significantly reducing both the programming and
the maintenance workload associated with the application.  In theory, because
the APIs interface to software that is curated by cloud providers, the
application leverages greater
reliability, scalability, performance, 
and availability in the implementations it calls upon through these APIs than
it would if those implementations were local to the application
(e.g. as locally available software libraries).

As a result, web-accessible APIs and the software implementations to which
they provide access are rapidly proliferating.
At the time of this writing, 
ProgrammableWeb~\cite{pweb}, a popular web API index, lists more than $11,000$
publicly available
web APIs and a nearly 100\% annual growth rate~\cite{pweb_growth}. 
Many of these APIs focus on commerce-oriented applications and training (e.g.
advertising, shopping, travel, etc.)
However several non-commercial entities have recently
also started publishing web 
APIs, e.g. IEEE~\cite{ieeeapis}, UC Berkeley~\cite{ucbapis}, and the US White
House~\cite{whitehouseapis}.  

This proliferation of web APIs demands new techniques and systems that
automate the maintenance and evolution of APIs. In particular, we require
support for defining and enforcing policies that control and manage the API 
lifecycle, i.e. \textit{API governance}.  A lack of governance can lead to 
security breaches, denial of service (DoS)
attacks, poor code reuse, violation of service-level agreements (SLAs), 
naming and branding issues, and abuse of digital 
assets by the API consumers. Unfortunately, most existing cloud platforms
within which web APIs are hosted provide only minimal governance support, e.g.
registration and API development authorization.  These mechanisms
(available from various commercial vendors such as
3Scale~\cite{3scale}, Apigee~\cite{apigee},
Layer7~\cite{layer7})
are important to policy implementation since governance policies often need to
express access control specifications.  
However, developers are still responsible for implementing governance policies
that {\em combine} features such as API versioning, access control,
dependency management, and SLA enforcement.  Moreover, each application must
implement its own governance -- there is no system for ensuring that the
policies implemented by different developers are consistent both in their
specification and their implementation.

In addition, many third party 
API management solutions have several limitations that make them difficult to
use to implement governance:
\begin{enumerate}
\item Third party API management solutions often operate outside the cloud that actually hosts the APIs. Therefore 
the API providers have to manage and pay for an additional service.
\item Third party solutions typically do not possess the ability to control and govern web APIs in an enforced manner. They cannot perform 
critical deployment-time governance checks on the APIs that are being developed and rolled out into the cloud. 
\item The API management solutions can fail independently of the cloud, thereby affecting the scalability and availability of the cloud-hosted APIs. 
\end{enumerate}

We postulate that governance must be implemented as a cloud service to
overcome these liabilities.
That is, instead of using a third party API management
solution that layers governance features on top of the cloud, 
we propose to provide API governance as a fundamental component of the cloud
platform.  By doing so, this approach
\begin{enumerate}
\item avoids inconsistencies and failure modes caused  
by integration, and configuration of third party services that are not
end-to-end integrated within the cloud fabric itself, 
\item leverages already-present cloud functionality such as fault tolerance,
high availability, elasticity, and end-to-end security implementation to
implement governance, and
\item unifies a vast diversity of API
governance features across all stages of API lifecycle
(development, deployment, evolution, deprecation, retirement). 
\end{enumerate}
As a native cloud service, such an
approach also simplifies and automates API governance implementation for
the administrators or ``DevOps'' teams responsible for service deployment and
maintenance.

Toward this end, we propose EAGER ({\bf E}nforced {\bf A}PI {\bf G}overnance
{\bf E}ngine for {\bf R}EST), a model and an architecture that augments existing
cloud platforms in order to facilitate API governance as a 
cloud-native feature. EAGER enforces proper versioning of APIs and supports dependency 
management and comprehensive policy enforcement at API deployment time. 
Deployment-time enforcement is an initial step in a complete governance
solution and ensures that APIs put into production meet all expectations of
the developer and other stakeholders.  EAGER also implements runtime
enforcement in a way similar to API management
solutions~\cite{XXXWS02APImanager,XXX,XXX}.  However, in this paper, we focus
on deployment-time governance as an emerging challenge faced by those
implementing scalable web service venues. 

As such, EAGER implements policies governing the APIs that are 
deployed within a single administrative domain.  Focusing governance on
the APIs simplifies both policy specification and the consistent
and automatic implementation of policies.  At the same time, it promotes
software maintainability by separating the API lifecycle management from that
of the service implementations and the client users.  That is, APIs are often
longer lived than the individual clients that use them or the implementations
of the services that they represent.  At the same time they represent the
``gateway'' between service consumption (API clients and users) and service
production (web service implementation).  Policy definition and enforcement at
the API level permits the service and client implementations to change
independently without the loss of governance control.

EAGER also promotes software maintainability by guaranteeing that 
developers reuse existing APIs when possible to create new software artifacts
(to prevent API redundancy and unverified API use). Concurrently, it
tracks changes made by developers to deployed web APIs to prevent
any backwards-incompatible API changes from being put into production.

EAGER includes a language for specifying 
API governance policies that is independent of both the APIs and services that
the policies govern.  The EAGER language is distinct from 
existing policy languages like WS-Policy~\cite{WSPolicy,soagovstandard}
in that it avoids the complexities of XML, 
and it incorporates a developer-friendly Python programming language syntax for 
specifying complex policy statements in a simple and 
intuitive manner. Moreover, we ensure that specifying the required policies 
is the only additional activity that API providers should perform in
order to benefit from EAGER. All other API governance related verification and 
enforcement work is carried out by the cloud platform automatically.

To evaluate the feasibility and performance of the proposed 
architecture, we implement EAGER as an extension to AppScale~\cite{appscale13}, 
an open source
cloud platform that emulates Google App Engine. We show that the EAGER 
architecture can be easily implemented in extant clouds with
minimal changes to the underlying platform technology. We further show that 
EAGER API governance and policy enforcement impose a negligible 
overhead on the application deployment process, and the overhead
is linear in the number of APIs present in the applications being validated.  
Finally, we show that EAGER is able to
scale to tens of thousands of deployed web APIs and hundreds of user 
defined governance policies.

In the sections that follow, we present some background on API governance
and overview the design and implementation of
EAGER. We then empirically evaluate EAGER using a wide range of APIs and
experiments.  Finally, we discuss future and related work, and conclude.
