I started this research with a comprehensive study on machine-readable API description languages. This initial survey lead me to develop a formal mechanism for automatically estimating the application porting effort between different APIs and API versions. My algorithm takes two API descriptions (source API and target API) as the input, which contain axiomatic semantics of API operations expressed in a Python-based syntax, and calculates a numeric value that is indicative of the effort that would be required in porting an application from the source API to the target API. This formal approach makes use of Dice coefficient as a means of quantifying the similarity between axiomatic semantic predicates of APIs, and also makes use of Hoare's consequence rules. The overall method has been validated against both randomly generated and real world API descriptions. I also combined my approach with k-means clustering in order to group API pairs into multiple categories (typically 2: easy and hard) based on the relative difficulty in porting applications between them. Our developer studies have shown that our automated mechanism closely resembles the porting effort (or relative difficulty) that human programmers associate with porting applications across web APIs.

Recently, we have further extended our automated porting effort calculation mechanism to also take the syntactic features of web APIs into consideration. This results in a two-phase API comparison algorithm where the first phase performs a syntactic comparison between APIs (i.e operations, input/output types), and the second phase performs the semantic analysis described earlier. The syntactic comparison is based on well-established programming languages research and static type checking methods.

In an effort to support design-time API governance as a cloud-native feature in modern clouds, I designed EAGER (Enforced API Governance Engine for REST), a system that augments PaaS clouds. EAGER intercepts all application and API deployment requests issued by developers, and validates them against a set of admin-specified policies. Application and API metadata are further subjected to a wide range of built-in sanity checks, which include a comprehensive API backwards-compatibility test based on the syntactic comparison method described earlier. Applications and APIs are only hosted in the cloud, if all the policy and sanity checks return successfully. We used a restricted subset of Python as the policy specification language, which allows programmers to write powerful governance policies in a very simple and intuitive way. EAGER's policy engine prevents all I/O operations, most third party library calls, and also global in-memory state, in order to perform all policy validations in a stateless and side-effect free manner. EAGER also supports dependency management, OAuth based authorization for all deployed APIs and does not require any major changes to the existing cloud architecture. I implemented an EAGER prototype using the AppScale open source PaaS (open source Google App Engine clone), and demonstrated that EAGER adds negligible overhead to the typical application deployment process in the cloud and it scales to handle thousands of APIs and policies.