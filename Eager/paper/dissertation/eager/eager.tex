\begin{figure*}[t]
\centering
%\includegraphics[scale=0.35]{eager_design}
\includegraphics[width=5in]{eager_design_2}
\caption{EAGER Architecture
\label{fig:eager_design}
}
\end{figure*}

To experiment with API governance in cloud environments, we devise EAGER
-- an architecture for implementing governance that is suitable for integration
as a cloud-native feature.
EAGER leverages existing SOA governance techniques and 
best practices, and adapts them to make them
suitable for cloud platform-level integration.
In this section, we
overview the high-level design of EAGER, its main
components, and the policy language.  Our design is motivated by two objectives.
First, we wish to verify that the integration among policy specification,
API specification,
deployment-time control, and run-time control is feasible in a cloud setting.
Secondly, we wish to use the design as the basis for a prototype
implementation that we could use to evaluate the impact of API governance
empirically.

EAGER is designed to be integrated with PaaS clouds. 
PaaS clouds accept code that is then
deployed within the platform so that it may make calls to kernel services
offered by the cloud platform, or other applications already
deployed in the cloud platform via their APIs.
EAGER intercepts all events related to application 
deployment within the cloud,
and enforces governance checks at deployment-time. 
When a policy verification check fails, 
EAGER aborts the deployment of the application, and logs the information
necessary to perform remediation.  EAGER assumes that it is integrated with
the cloud, and that the cloud initiates 
in a policy compliant state ({\em i.e.} there are
no policy violations when the cloud is first launched before any applications are
deployed).  
We use the term
``initiates'' to differentiate the first clean launch of the cloud, from
a platform restart.  EAGER must be able to maintain compliance across restarts,
but it assumes that when the cloud is first installed and suitably tested, it is in
a policy compliant state.
Moreover, it maintains the cloud
in a policy compliant state at all times.  That is, with EAGER active, the cloud
is automatically prevented from transitioning out of policy compliance due to a
change in the applications it hosts.

Figure~\ref{fig:eager_design} illustrates the main components of EAGER (in
blue), and their interactions. Solid arrows represent the interactions that take place
during application deployment-time, before an application has been validated
for deployment. Short-dashed arrows indicate the interactions that take place
during deployment-time, after an application has been successfully validated.
Long-dashed arrows indicate interactions at run-time. The diagram also outlines the
components of EAGER that are used to provide deployment-time  control and run-time control.
Note that some components participate in interactions related to both deployment and
run-time control (e.g. metadata manager).

EAGER is invoked by the cloud whenever a user
attempts to deploy an application in the cloud.
The cloud's application deployment mechanisms must be altered so that
each deployment request is
intercepted by EAGER, which then performs the required governance checks.
If a governance check fails, EAGER preempts the application deployment,
logs relevant data pertaining to the event for later analysis,  and
returns an error. Otherwise, it proceeds with the application deployment by
activating the deployment mechanisms on the user's 
behalf. 

Architecturally, the deployment action requires three inputs: the policy
specification governing the deployment, the application code to be deployed, and a
specification of the APIs that the application exports.
EAGER assumes that cloud administrators have developed and installed policies
(stored in the metadata manager)
that are to be checked against all deployments.  API specifications for the
application must also be available to the governance framework.  Because the API
specifications are to be derived from the code (and are, thus, under developer
control and not administrator control) our design assumes that automated
tools are available
to perform analysis on the application, and
generate API specifications in a suitable API specification language. These
specifications must be present
when the deployment request is considered by the platform.  In the prototype
implementation described in section~\ref{sec:eager_prototype_impl}, the API specifications are
generated as part of the application development process ({\em e.g.} by the
build system).  They may also
be offered as a trusted service hosted in the cloud. 
In this case, developers will submit their source code
to this service, which will generate the necessary API specifications in the cloud, and trigger
the application deployment process via EAGER.

The proposed architecture does not require major changes to the 
existing components of the cloud, since its deployment mechanisms are likely to
be web service based.  However, EAGER does require integration at the platform level.
That is, it must be a trusted component in the cloud platform. 
%All the 
%EAGER components can be easily implemented as feature additions. 
%The only noteworthy change that is required is the mechanism to intercept application deployment requests and act upon them. 
%This can be done without changing the existing components of the cloud.
%Following subsections further describe the design and responsibilities of EAGER components.

\subsection{Metadata Manager}
The metadata manager stores all the API metadata in EAGER. This metadata 
includes policy specifications,  API names, versions, specifications and 
dependencies.
It uses the dependency information to compute the dependency tree 
among 
all deployed APIs and applications. Additionally, the metadata manager
also keeps track of developers, their subscriptions to various APIs, 
and the access credentials (API keys) issued to them. 
For these purposes,
the metadata manager must logically include both a database,
and an identity management system.
%management system. The developer information may be stored in a specialized user
%store ({\em e.g.} LDAP).

The metadata manager is exposed to other components through a well defined web service interface.
This interface allows querying existing API metadata and updating them. In the proposed model, the stored metadata is updated 
occasionally -- only when a new application is deployed or when a developer subscribes to a published API. 
Therefore the Metadata Manager
does not need to support a very high write throughput. This performance
characteristic allows the Metadata Manager to be implemented with strong 
transactional semantics,
which reduces the development overhead of other components that rely on metadata manager. 
Availability can be improved via simple replication methods.

\subsection{API Deployment Coordinator} 
\label{sec:adc}
The API Deployment Coordinator (ADC)
intercepts all application deployment requests, and determines whether they are
suitable for deployment, based on a set of policies specified by the cloud
administrators. It receives application deployment requests via a web service
interface. At a high-level, ADC is the most important entity in the EAGER's deployment-time
control strategy.

An application deployment request contains the name of the application,
version number, names and versions of the APIs exported by the application,
detailed API specifications, and other API dependencies as declared by the
developer. Application developers only need to specify explicitly the name and
version of the application and the list of dependencies (i.e. APIs consumed by
the application). All other metadata can be computed automatically by
performing introspection on the application source code. 
%In our prototype
%implementation of EAGER, we have developed special tools that perform these
%metadata calculations, including the automatic generation of API
%specifications.

The API specifications used to describe the web APIs should state the
operations and the schema of their inputs and outputs.  Any standard API
description language can be used for this purpose, as long as it clearly
describes the schema of the requests and responses. For describing REST
interfaces, we can use Web Application Description Language (WADL)~\cite{hl:wadl}, Swagger~\cite{hl:swagger},
RESTful API Modeling Language (RAML) or any other language that provides similar functionality. %Our research
%currently focuses on RESTful 
%services only, but our design can also be adapted to govern SOAP services in
%the cloud, in which case Web Services Description Language (WSDL) can be used
%to create API specifications.

When a new deployment request is received, the ADC checks whether the
application declares any API dependencies. If so, it queries the metadata
manager to make sure that all the declared dependencies are already available
in the cloud.  Then it inspects the enclosed application metadata to see if
the current application exports any web APIs. If the application exports at
least one API, the ADC makes another call to the metadata manager, and retrieves
any existing metadata related to that API. If the metadata manager cannot
locate any data related to the API in question, ADC assumes it to be a brand
new API (i.e. no previous version of that API has been deployed in the cloud),
and proceeds to the next step of the governance check, which is policy
validation. However, if any metadata regarding the API is found, then the ADC
is dealing with an API update. In this case, the ADC compares the old API
specifications with the latest ones provided in the application deployment
request to see if they are compatible.

To perform this API compatibility verification, the ADC checks to see whether
the latest specification of an API contains all the operations available in
the old specification. If the latest API specification is missing at least one
operation that it had previously, the ADC reports this to the user and aborts
the deployment. If all the past operations are present in the latest
specification, the ADC performs a type check to make sure that all past and
present operations are type compatible. This is done by performing recursive
introspection on the input and output data types declared in the API
specifications. EAGER looks for type compatibility based on the following
rules inspired by Hoare logic~\cite{Hoare:1969:ABC:363235.363259}, and the
rules of type inheritance from object oriented programming.

\begin{itemize}
\item New version of an input type is compatible with the old version of an input type, 
if the new version contains either all or less attributes than the 
old version, and any new attributes that are unique to the new version are optional.
\item New version of an output type is compatible with the old version of an output type, 
if the new version contains either all or more attributes than the 
old version.
\end{itemize}

In addition to the type checks, ADC may also compare other parameters declared in the API specifications
such as HTTP methods, mime types and URL patterns. We have also explored and 
published results on using a combination of syntactic and semantic comparison
to determine the compatibility between APIs~\cite{6930607,jayathilaka2014using}.
Once the API specifications have been successfully compared without error, and 
the compatibility established, the ADC initiates policy validation. 

\subsection{EAGER Policy Language and Examples}
\label{sec:policy-lang}
Policies are specified by cloud
or organizational administrators using a subset of the popular 
Python programming language.
This design choice is motivated by several reasons.
\begin{itemize}
\item A high-level programming language such as Python is easier to learn and use
for policy implementors. 
\item Platform implementors can use existing Python interpreters to parse
and execute policy files. Similarly, policy implementors can use existing Python
development tools to write and test policies.
\item In comparison to declarative policy languages (e.g. WS-Policy),
a programming language like Python offers more flexibility and expressive power.
For example, a policy may perform some local computation, and use the results
in its enforcement clauses. The control flow tools of the language (e.g. conditionals, loops) 
facilitate specifying complex policies.
\item The expressive power of the language can be closely regulated by controlling
the set of allowed built-in modules and functions.
\end{itemize}

We restrict the language to prevent state from being preserved across
policy validations. In particular, the EAGER policy interpreter disables 
file and network operations, third party library calls, 
and other language features that allow
state to persist across invocations.  
In addition, EAGER processes each 
policy independently of others (i.e. each policy must be self-contained and 
access no external state).  All other language constructs and 
language features can be used to specify policies in EAGER.

To accommodate built-in language APIs that the administrators trust by {\em fiat},
all module and function restrictions of the EAGER policy language are enforced
through a configurable white-list. The policy engine evaluates each module and function
reference found in policy specifications
against this white-list to determine whether they are allowed in the context of
EAGER. Cloud administrators have the freedom
to expand the set of allowed built-in and third party modules by making
changes to this white-list.

As part of policy language, EAGER
defines a set of assertions that policy writers can use to specify various 
checks to perform on the applications. 
Listing~\ref{lst:assertions} shows the assertions currently supported by EAGER.

{\footnotesize 
\begin{lstlisting}[language=Python, frame=single, 
caption={Assertions supported by the EAGER policy language.}, label={lst:assertions}]
assert_true(condition, optional_error_msg)
assert_false(condition, optional_error_msg)
assert_app_dependency(app, d_name, d_version)
assert_not_app_dependency(app, d_name, d_version)
assert_app_dependency_in_range(app, name,\
  lower, upper, exclude_lower, exclude_upper)
\end{lstlisting}
}

%\begin{itemize}
%\item assert\_true(condition, optional\_error\_msg)
%\item assert\_false(condition, optional\_error\_msg)
%\item assert\_app\_dependency(app, d\_name, d\_version)
%\item assert\_not\_app\_dependency(app, d\_name, d\_version)
%\item assert\_app\_dependency\_in\_range(app, name, lower, upper, exclude\_lower, exclude\_upper)
%\end{itemize}

In addition to these assertions, EAGER adds a function
called ``compare\_versions'' to the list 
of available built-in functions. Policy
implementors can use this function to compare version 
number strings associated with
applications and APIs.

%Basing the policy language on Python allows EAGER to leverage
%existing programming tools to edit and debug policy files. Using a real programming 
%language to specify policies, enables administrators to implement governance policies with
%arbitrary complexity and logic with ease. 

In the remainder of this section we illustrate the use of the policy language
through several examples.
The first example policy, shown in listing~\ref{lst:comp_versions}, 
mandates that any application or mash-up
that uses both Geo and Direction APIs must adhere to certain versioning 
rules. More specifically, if the application uses Geo 3.0 or higher, it must use
Direction 4.0 or higher. Note that the version numbers are compared using the
``compare\_versions'' functions described earlier.

{\footnotesize
\begin{lstlisting}[language=Python, frame=single, showstringspaces=false,
caption={Enforcing API version comparison}, label={lst:comp_versions}]
g = filter(lambda dep: dep.name == `Geo', app.dependencies)
d = filter(lambda dep: dep.name == `Direction', app.dependencies)
if g and d:
  g_api, d_api = g[0], d[0]
  if compare_versions(g_api.version, `3.0') >= 0:
    assert_true(compare_versions(d_api.version, `4.0') >= 0)
\end{lstlisting}
}

In listing~\ref{lst:comp_versions}, \textit{app} is a special immutable logical variable available to
all policy files. This variable allows policies to access information
pertaining to the current application deployment request. The assert\_true and assert\_false
functions allow testing for arbitrary conditions, thus greatly improving the expressive
power of the policy language.

Listing~\ref{lst:roles} shows a policy file that mandates that all applications deployed
by the ``admin@test.com'' user must have role-based authentication enabled, so that only
users in the ``manager'' role can access them. To carry out this check the policy accesses
the security configuration specified in the application descriptor (e.g. the
web.xml for a Java application).

{\footnotesize
\begin{lstlisting}[language=Python, frame=single, showstringspaces=false, 
caption={Enforcing role-based authorization.}, label={lst:roles}]
if app.owner == `admin@test.com':
  roles = app.web_xml[`security-role']
  constraints = app.web_xml[`security-constraint']
  assert_true(roles and constraints)
  assert_true(len(roles) == 1)
  assert_true(`manager' == roles[0][`role-name'])
\end{lstlisting}
}

Listing~\ref{lst:swagger} shows an example policy, which mandates that all deployed APIs must explicitly
declare an operation which is accessible through the HTTP OPTIONS method. This policy further ensures
that these operations return a description of the API in the Swagger~\cite{hl:swagger} machine-readable API
description language.

{\footnotesize
\begin{lstlisting}[language=Python, frame=single, showstringspaces=false, 
caption={Enforcing APIs to publish a description.}, label={lst:swagger}]
options = filter(lambda op : op.method == `OPTIONS',  
  api.operations)
assert_true(options, `API does not support OPTIONS')
assert_true(options[0].type == `swagger.API', 
  `Does not return a Swagger description')
\end{lstlisting}
}

Returning machine-readable API descriptions from web APIs 
makes it easier to automate the API discovery and consumption processes. Several other
research efforts confirm the need for such descriptions~\cite{Verborgh:2012:FDB:2307819.2307828,Steiner:2011:FHC:1967428.1967433}. 
A policy such as this
can help enforce such practices, thus resulting in a high-quality
API ecosystem in the target cloud. 

The policy above also shows the use of the second and
optional string argument to 
the assert\_true function (the same is supported by assert\_false as well). 
This argument can be used to specify
a custom error message that will be returned to the application developer, if his/her application
violates the assertion in question.

The next example policy prevents developers from introducing
dependencies on deprecated web APIs. Deprecated APIs 
are those that have been flagged
by their respective authors for removal 
in the near future. Therefore introducing dependencies on such
APIs is not recommended. The policy in listing~\ref{lst:deprecated} 
enforces this condition in the cloud.

{\footnotesize
\begin{lstlisting}[language=Python, frame=single, showstringspaces=false, 
caption={Preventing dependencies on deprecated APIs.}, label={lst:deprecated}]
deprecated = filter(
  lambda dep : dep.status == 'DEPRECATED', 
  app.dependencies)
assert_false(deprecated, 
  'Must not use a deprecated dependency')
\end{lstlisting}
}

{\footnotesize
\begin{lstlisting}[language=Python, frame=single, showstringspaces=false, 
caption={Tenant-aware policy enforcement.}, label={lst:tenants}]
if app.owner.endswith(`@engineering.test.com'):
  assert_app_dependency(app, `Log', `1.0')
elif app.owner.endswith(`@sales.test.com'):
  assert_app_dependency(app, `AnalyticsLog', `1.0')
else:
  assert_app_dependency(app, `GenericLog', `1.0')
\end{lstlisting}
}

Our next example presents a policy that enforces governance 
rules in a user-aware (i.e. tenant-aware) manner. Assume
a multi-tenant private PaaS cloud that is being 
used by members of the development
team and the sales team of a company. The primary goal in this case
is to ensure that applications deployed by both teams
log their activities using a set of preexisting logging APIs. 
However, we further want to ensure that applications
deployed by the sales team log their activities using 
a special analytics API. A policy such as the one
in listing~\ref{lst:tenants} can enforce these conditions.

The example in listing~\ref{lst:paging} shows a policy, which mandates 
that all HTTP GET operations exposed by APIs must support
paging. APIs that do so define two input parameters 
named ``start'' and ``count'' to the GET call.

{\footnotesize
\begin{lstlisting}[language=Python, frame=single, showstringspaces=false, 
caption={Enforcement of paging functionality in APIs.}, label={lst:paging}]
for api in app.api_list:
  get = filter(lambda op : op.method == `GET',  
    api.operations)
  for op in get:
    param_names = map(lambda p : p.name, 
      op.parameters)
    assert_true(`start' in param_names and 
      `count' in param_names)
\end{lstlisting}
}

This policy accesses the metadata of API operations that 
is available in the API descriptions.
Since API descriptions are auto-generated 
from the source code of the APIs, this policy indirectly
references information pertaining to the actual API implementations.

Finally, we present an example for the HTTP POST method.  The 
policy in listing~\ref{lst:oauth} mandates 
that all POST operations exposed by an API are secured 
with OAuth version 2.0.

{\footnotesize
\begin{lstlisting}[language=Python, frame=single, showstringspaces=false, 
caption={Enforcement of OAuth-based authentication for APIs.}, label={lst:oauth}]
for api in app.api_list:
  post = filter(lambda op : op.method == `POST', 
  	api.operations)
  for op in post:
    assert_true(op.authorizations.get(`oauth2'))
\end{lstlisting}
}

EAGER places no restrictions on how many policy files are specified by 
administrators. Applications are validated against each policy file. Failure
of any assertion in any policy file causes the ADC to abort 
application deployment. Once an application is checked against all
applicable policies, ADC persists the latest application and API metadata into
the Metadata Manager.  At this point, the ADC may report success to the user,
and proceed with application deployment. In a PaaS setting
this deployment activity typically involves three steps:

\begin{enumerate}
\item Deploy the application in the cloud application run-time (application server).
\item Publish the APIs enclosed in the application and their specifications to
the API Discovery Portal or catalog.
\item Publish the APIs enclosed in the application to an API Gateway server.
\end{enumerate}

Step $1$ is required to complete the application deployment in the cloud even
without EAGER. We explain the significance of steps $2$ and $3$ in the 
following subsections.

\subsection{API Discovery Portal} 
The API Discovery Portal (ADP) is an online
catalog where developers can browse available web APIs. Whenever the ADC
approves and deploys a new application, it registers all the APIs exported by
the application in ADP.  EAGER mandates that any developer interested in using
an API, first subscribe to that API and obtain the proper credentials (API
keys) from the ADP. The API keys issued by the ADP can consist of an
OAuth~\cite{oauth2}
access
token (as is typical of many commercial REST-based web services) 
or a similar authorization credential, which can be used to identify the
developer/application that is invoking the API. This credential
validation process is used for auditing, and run-time governance in EAGER.

The API keys issued by the ADP are stored in the metadata manager. When a
programmer develops a new application using one or more API dependencies, we
require the developer to declare its dependencies along with the API
keys obtained from the ADP. The ADC verifies this information against
the metadata manager as a part of its dependency check, and ensures that the
declared dependencies are correct and the specified API keys are valid. 

Deployment-time governance policies
may further incentivize the declaration of API 
dependencies explicitly by making it 
impossible to call an API without first declaring it as a dependency along
with the proper API keys. These types of policies can be implemented
with minor changes to the
application run-time in the cloud so that it loads the API credentials from
the dependency declaration provided by the application developer.

In addition to API discovery, the ADP also provides a user
interface for API authors to select their own APIs and deprecate them or
retire them. Deprecated APIs will be removed from the API search
results of the portal, and application developers will no longer be able to 
subscribe to them. However, already existing subscriptions and API keys will continue
to work until the API is eventually retired. 
The deprecation is considered a courtesy notice for application developers
who have developed applications using the API, to migrate their code to a newer version
of the API. 
Once retired, any applications that have
not still been migrated to the latest version of the API will cease to operate.

\subsection{API Gateway} 
Run-time governance of web services by systems such as
Synapse~\cite{synapse} make use of an API ``proxy'' or gateway.
The EAGER API gateway does so to intercept API calls and validate 
the API keys contained within them.
EAGER intercepts requests by blocking direct access to the APIs in the
application run-time (app servers), and publishing the API Gateway address as
the API endpoint in the ADP. We do so via firewall rules
that prevent the cloud app servers from receiving any
API traffic from a source other than the API gateway. Once the API gateway validates
an API call, it routes the message to the
application server in the cloud platform that hosts the API.

The API gateway can be implemented via one or more load-balanced servers.
In addition to API key validation, the API gateway can perform other
functions such as monitoring, throttling (rate limiting), 
and run-time policy validation. 
