In this chapter, we describe EAGER, a model and a software architecture that 
facilitates API governance as a cloud-native feature. EAGER supports comprehensive policy
enforcement, dependency management, and a variety of other deployment-time API
governance features. It promotes many software development and maintenance
best practices including versioning, code reuse, and API backwards
compatibility retention. EAGER also includes a language based on Python that enables
creating, debugging, and maintaining API governance policies in a simple and intuitive
manner. EAGER can be built into cloud platforms that are used to host APIs
to automate governance tasks that otherwise require custom code or developer intervention.

Our empirical results, gathered using a prototype of EAGER developed for AppScale,
show that EAGER adds negligibly small overhead to the cloud application 
deployment process, and the overhead grows linearly
with the number of APIs deployed. We also show that EAGER scales well 
to handle tens of thousands of APIs and hundreds of policies. Based on our
results we conclude that efficient and automated policy enforcement is feasible
in cloud environments. Furthermore, we find that policy enforcement at deployment-time can help
cloud administrators and application developers achieve administrative 
conformance and developer best practices with respect to cloud-hosted 
web applications.

As part of our future work, we plan to investigate the degree to which
deployment-time governance can be expanded.
Run-time API governance imposes a number of new scalability and
reliability challenges.  By offloading as much of the governance overhead to
deployment-time as possible, EAGER ensures that the impact of run-time
governance is minimized.  

We also plan to investigate the specific language features that are essential
to EAGER's combined deployment-time and run-time approach.  The use of Python
in the prototype proved convenient from a programmer productivity perspective.
It is not yet clear, however, whether the full set of language features that
we have left unrestricted are necessary.  By minimizing the policy language
specification we hope to make its implementation more efficient, less
error prone to develop and debug, and more amenable to automatic analysis.

Another future research direction is the integration of policy language and
run-time API governance.
We wish to explore the possibility of using the same Python-based
policy language for
specifying policies that are enforced on APIs at run-time (i.e. on individual
API calls). Since API calls
far more frequent than API deployment events, we should evaluate
the performance aspects of the policy engine to make this integration practically useful.
