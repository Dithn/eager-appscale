\begin{figure*}[t]
\centering
%\includegraphics[scale=0.35]{eager_design}
\includegraphics[width=5in]{eager_design_2}
\caption{EAGER Architecture
\label{fig:eager_design}
}
\end{figure*}

To experiment with implementation of API governance, we have developed EAGER
-- an architecture for implementing governance suitable for integration
as a cloud-native feature.
%EAGER leverages existing SOA governance techniques and 
%best practices and adapts them to make them
%suitable for cloud platform-level integration.
In this section, we
overview the high-level design of EAGER, describe its main
components and the policy language.  Our goal in its design is two fold.
First, we wished to verify that the integration between policy specification,
API specification,
deployment control, and run-time control is feasible in a cloud setting.
Secondly, we wished to use the design as the basis for a prototype
implementation that we could use to evaluate the impact of API governance
empirically.

EAGER is designed to be integrated with PaaS clouds. 
PaaS clouds accept code that is then
deployed within the platform so that it may make calls to existing services
(cloud SDK) supported by the platform.
EAGER is designed to intercept all events related to application 
deployment within the cloud
and enforces deployment-time governance checks and
logging. 
%These governance features include API metadata validation, 
%dependency validation, policy validation and 
%API backward compatibility
%checking. 
When a policy verification check fails, 
EAGER aborts the deployment of the application and logs the information
necessary to perform remediation.  EAGER assumes that it is integrated with
the cloud and that the cloud initiates\footnote{We use the term
``initiates'' to differentiate the first clean installation of the cloud, from
a cloud restart.  EAGER must be able to maintain compliance across restarts,
but it assumes that when the cloud is installed and suitably tested, it is in
a policy compliant state.} 
in a compliant state ({\em i.e.} there are
no policy violations when the cloud is started before any applications are
deployed).  It tries to maintain the cloud
in a ``governed'' state at all times.  That is, with EAGER active, the cloud
is
automatically prevented from transitioning out of policy compliance due to a
change in the applications it hosts.

%In this work we focus on the deployment-time governance capabilities of EAGER. 
%At present, it also implements the same run-time governance features that are
%common to most API management facilities (which is necessary but not the
%subject of the research we present in this paper).
%However, our experience with the interplay between the new deployment-time
%governance techniques we discuss and the extant methodologies for run-time
%features leads to new possibilities for run-time governance as well (which we
%discuss as future work).

Figure~\ref{fig:eager_design} illustrates the main components of EAGER (in
blue) and their interactions. Solid arrows represent the interactions that take place
during application deployment-time, before an application has been validated
for deployment. Short-dashed arrows indicate the interactions that take place
during deployment-time, after an application has been successfully validated.
Long-dashed arrows indicate interactions at run-time. The diagram also outlines the
components of EAGER that are used to provide deployment  control and run-time control.
Note that some components participate in interactions related to both deployment and
run-time control (e.g. Metadata Manager).

EAGER must be invoked by the cloud whenever a user
attempts to deploy an application in the cloud.
%the developer tools available on his/her workstation that activate the target
%cloud's deployment mechanisms. 
%In some cloud
%implementations these tools could be available as an online service accessed
%via a web browser. In either case, 
The cloud's application deployment mechanisms must be altered so that
each deployment request is
intercepted by EAGER, which then performs the required governance checks.
If a governance check fails, EAGER will preempt the application deployment,
log relevant data pertaining to the event for later analysis,  and
return an error. Otherwise, it proceeds with the application deployment by
activating the deployment mechanisms on the user's 
behalf. 

Architecturally, the deployment action requires three inputs: the policy
specification governing the deployment, the code to be deployed, and a
specification of the APIs that the code exports.
EAGER assumes that cloud administrators have developed and installed policies
(stored in the Metadata Manager)
that are to be checked against all deployments.  API specifications for the
application must also be available to the governance engine.  Because the API
specifications are to be derived from the code (and are, thus, under developer
control and not administrator control) our design assumes that automated
tools are available
to perform analysis on the application, and
generate API specifications in a suitable API specification language. These
specifications must be present
when the deployment request is considered by the platform.  In the prototype
implementation described in Section~\ref{sec:prototype_impl}, the API specifications are
generated as part of the application development process ({\em e.g.} by the
build system).  They may also
be offered as a trusted service hosted in the cloud. 
In this case, developers will submit their source code
to this service, which will generate the necessary API specifications in the cloud and trigger
the application deployment process via EAGER.

The proposed architecture is designed not to require major changes to the 
existing components of the cloud since its deployment mechanisms are likely to
be web service based.  However, EAGER does require integration at the service level
({\em e.g.} it must be a trusted service component in a PaaS cloud). 
%All the 
%EAGER components can be easily implemented as feature additions. 
%The only noteworthy change that is required is the mechanism to intercept application deployment requests and act upon them. 
%This can be done without changing the existing components of the cloud.
%Following subsections further describe the design and responsibilities of EAGER components.

\subsubsection{Metadata Manager}
The Metadata Manager stores all the API metadata in EAGER. This metadata 
includes policy specifications,  API names, versions, specifications and 
dependencies.
It uses the dependency information to compute the dependency tree 
among 
all deployed APIs and applications. Additionally, the Metadata Manager
also keeps track of developers, their subscriptions to various APIs and the access credentials (API keys) issued to them. 
For these purposes,
the Metadata Manager must logically include both a database
and an identity management system.
%management system. The developer information may be stored in a specialized user
%store ({\em e.g.} LDAP).

The Metadata Manager is exposed to other components through a well defined web service interface.
This interface allows querying existing API metadata and updating them. In the proposed model, the stored metadata is updated 
occasionally (only when a new application is deployed or when a developer subscribes to a published API). Therefore the Metadata Manager
does not need to support a very high write throughput. This performance
characteristic allows the Metadata Manager to be implemented with strong 
transactional semantics,
which reduces the development overhead of other components that rely on Metadata Manager. Availability can be improved via
simple replication methods.

\subsubsection{API Deployment Coordinator} 
\label{sec:adc}
The API Deployment Coordinator (ADC)
intercepts all application deployment requests and determines whether they are
suitable for deployment, based on a set of policies specified by the cloud
administrators. It receives application deployment requests via a web service
interface. At a high-level, ADC is the most important entity in the EAGER deployment
control strategy.

An application deployment request contains the name of the application,
version number, names and versions of the APIs exported by the application,
detailed API specifications and other API dependencies as declared by the
developer. Application developers only need to specify explicitly the name and
version of the application and the list of dependencies (i.e. APIs consumed by
the application). All other metadata can be computed automatically by
performing introspection on the application source code. 
%In our prototype
%implementation of EAGER, we have developed special tools that perform these
%metadata calculations, including the automatic generation of API
%specifications.

The API specifications used to describe the web APIs should specify the
operations and the schema of their inputs and outputs.  Any standard API
description language can be used for this purpose, as long as it clearly
describes the schema of the requests and responses. For describing REST
interfaces, we can use Web Application Description Language (WADL)~\cite{hl:wadl}, Swagger~\cite{hl:swagger},
RESTful API Modeling Language (RAML) or any other language that provides similar functionality. %Our research
%currently focuses on RESTful 
%services only, but our design can also be adapted to govern SOAP services in
%the cloud, in which case Web Services Description Language (WSDL) can be used
%to create API specifications.

When a new deployment request is received, the ADC checks whether the
application declares any API dependencies. If so, it queries the Metadata
Manager to make sure that all the declared dependencies are already available
in the cloud.  Then it inspects the enclosed application metadata to see if
the current application exports any web APIs. If the application exports at
least one API, the ADC makes another call to the Metadata Manager and pulls
any existing metadata related to that API. If the Metadata Manager cannot
locate any data related to the API in question, ADC assumes it to be a brand
new API (i.e. no previous version of that API has been deployed in the cloud),
and proceeds to the next step of the governance check, which is policy
validation. However, if any metadata regarding the API is found, then the ADC
is dealing with an API update. In this case, the ADC compares the old API
specifications with the latest ones provided in the application deployment
request to see if they are compatible.

To perform this API compatibility verification, the ADC checks to see whether
the latest specification of an API contains all the operations available in
the old specification. API specifications are generated at the application developer's
end and submitted to EAGER along with the application deployment request.
If the latest API specification is missing at least one
operation that it had previously, the ADC reports this to the user and aborts
the deployment. If all the past operations are present in the latest
specification, the ADC performs a type check to make sure that all past and
present operations are type compatible. This is done by performing recursive
introspection on the input and output types declared in the API
specifications. EAGER looks for type compatibility based on the following
rules inspired by Hoare logic~\cite{Hoare:1969:ABC:363235.363259} and the
rules of type inheritance from object oriented programming:
\begin{itemize}
\vspace{0.1in}
\item New version of an input type is compatible with the old version of an input type, if the new version contains either all or less attributes than the 
old version, and any new attributes that are unique to the new version are optional.
\vspace{0.1in}
\item New version of an output type is compatible with the old version of an output type, if the new version contains either all or more attributes than the 
old version.
\vspace{0.1in}
\end{itemize}
In addition to the type checks, ADC may also compare other parameters declared in the API specifications
such as HTTP methods, mime types and URL patterns.
Once the API specifications have been successfully compared without error,
the ADC initiates policy validation. 

\subsubsection{EAGER Policy Language and Examples}
\label{sec:policy-lang}
Policies are specified by cloud
or organizational administrators using a subset of an object oriented language
(we chose Python for the prototype).
We restrict the language to prevent state from being preserved across
policy validations. In particular, the EAGER policy interpreter disables 
file and network operations, third party library calls, 
and intrinsics that allow
state to persist across invocations.  
In addition, EAGER processes each 
policy independently of others (i.e. each policy must be self-contained and 
access no external state).  All other language constructs and 
language features can be used to specify policies in EAGER.

To accommodate built-in language APIs that the administrators trust by {\em fiat},
all module and function restrictions of the EAGER policy language are enforced
through a configurable white-list. The policy engine evaluates each module and function
reference against this white-list to determine whether they are allowed in the context of
EAGER. Cloud administrators have the freedom
and flexibility to expand the set of allowed built-in and third party modules by making
changes to this white-list.

As part of policy language, EAGER
defines a set of assertions that policy writers can use to specify various 
checks to perform on the applications. 
Currently, this assertion list includes:

%\vspace{0.25in}
\vspace{0.05in}
{\footnotesize 
\begin{lstlisting}[language=Python, frame=single]
assert_true(condition, optional_error_msg)
assert_false(condition, optional_error_msg)
assert_app_dependency(app, d_name, d_version)
assert_not_app_dependency(app, d_name, d_version)
assert_app_dependency_in_range(app, name,\
  lower, upper, exclude_lower, exclude_upper)
\end{lstlisting}
}

%\begin{itemize}
%\item assert\_true(condition, optional\_error\_msg)
%\item assert\_false(condition, optional\_error\_msg)
%\item assert\_app\_dependency(app, d\_name, d\_version)
%\item assert\_not\_app\_dependency(app, d\_name, d\_version)
%\item assert\_app\_dependency\_in\_range(app, name, lower, upper, exclude\_lower, exclude\_upper)
%\end{itemize}

In addition to these assertions, EAGER adds a function
called ``compare\_versions'' to the list 
of available built-in functions. Policy
writers can use this function to compare version 
number strings associated with
applications and APIs.

%Basing the policy language on Python allows EAGER to leverage
%existing programming tools to edit and debug policy files. Using a real programming 
%language to specify policies, enables administrators to implement governance policies with
%arbitrary complexity and logic with ease. 

In the remainder of this section we illustrate the use of the policy language
through examples.
The first example policy mandates that any application or mash-up
that uses both Geo and Direction APIs must adhere to certain versioning 
rules. More specifically, if the application uses Geo 3.0 or higher, it must use
Direction 4.0 or higher. Note that the version numbers are compared using the
``compare\_versions'' functions described earlier.

\vspace{0.05in}
{\footnotesize
\begin{lstlisting}[language=Python, frame=single, showstringspaces=false]
g = filter(lambda dep: dep.name == `Geo', \
	app.dependencies)
d = filter(lambda dep: dep.name == `Direction',\
	app.dependencies)
if g and d:
  g_api, d_api = g[0], d[0]
  if compare_versions(g_api.version, `3.0') >= 0:
    assert_true(compare_versions(d_api.version, `4.0') >= 0)
\end{lstlisting}
}
\vspace{0.05in}

In the above example, \textit{app} is a special immutable logical variable available to
all policy files. This variable allows policies to access information
pertaining to the current application deployment request. The assert\_true and assert\_false
functions allow testing for arbitrary conditions, thus greatly improving the expressive
power and flexibility of the policy language.

The next example shows a policy file that mandates that all applications deployed
by the ``admin@test.com'' user must have role-based authentication enabled, so that only
users in the ``manager'' role can access them. To carry out this check the policy accesses
the security configuration specified in the application descriptor (e.g. the
web.xml for a Java application).

\vspace{0.05in}
{\footnotesize
\begin{lstlisting}[language=Python, frame=single, showstringspaces=false]
if app.owner == `admin@test.com':
  roles = app.web_xml[`security-role']
  constraints = app.web_xml[`security-constraint']
  assert_true(roles and constraints)
  assert_true(len(roles) == 1)
  assert_true(`manager' == roles[0][`role-name'])
\end{lstlisting}
}
\vspace{0.05in}

Next, we present an example policy, which mandates that all deployed APIs must explicitly
declare an operation which is accessible through the HTTP OPTIONS method. This policy further ensures
that these operations return a description of the API in the Swagger~\cite{hl:swagger} machine-readable API
description language.

\vspace{0.05in}
{\footnotesize
\begin{lstlisting}[language=Python, frame=single, showstringspaces=false]
options = filter(lambda op : op.method == `OPTIONS',  
  api.operations)
assert_true(options, `API does not support OPTIONS')
assert_true(options[0].type == `swagger.API', 
  `Does not return a Swagger description')
\end{lstlisting}
}
\vspace{0.05in}

Returning machine-readable API descriptions from web APIs 
makes it easier to automate the API discovery and consumption processes. Several other
research efforts confirm the need for such descriptions~\cite{Verborgh:2012:FDB:2307819.2307828,Steiner:2011:FHC:1967428.1967433}. 
A policy such as this
can help enforce such practices, thus resulting in a high-quality
API ecosystem in the target cloud. 

The policy above also shows the use of the second and
optional string argument to 
the assert\_true function (the same is supported by assert\_false as well). 
This argument can be used to specify
a custom error message that will be returned to the application developer, if his/her application
violates the assertion in question.

The next example is a relatively simple policy file 
that prevents developers from introducing
dependencies on deprecated web APIs. Deprecated APIs 
are those that have been flagged
by their respective authors for removal 
in the near future. Therefore introducing dependencies on such
APIs is not recommended. The following policy will 
enforce this condition in the cloud.

\vspace{0.05in}
{\footnotesize
\begin{lstlisting}[language=Python, frame=single, showstringspaces=false]
deprecated = filter(
  lambda dep : dep.status == 'DEPRECATED', 
  app.dependencies)
assert_false(deprecated, 
  'Must not use a deprecated dependency')
\end{lstlisting}
}
\vspace{0.05in}

Our next example presents a policy that enforces governance 
rules in a user-aware (i.e. tenant-aware) manner. Assume
a multi-tenant private PaaS cloud that is being 
used by members of the development
team and the sales team of a company. The primary goal in this case
is to ensure that applications deployed by both teams
log their activities using a set of preexisting logging APIs. 
However, we further want to ensure that applications
deployed by the sales team log their activities using 
a special analytics API. A policy such as the one
that follows can enforce these conditions.

\vspace{0.05in}
{\footnotesize
\begin{lstlisting}[language=Python, frame=single, showstringspaces=false]
if app.owner.endswith(`@engineering.test.com'):
  assert_app_dependency(app, `Log', `1.0')
elif app.owner.endswith(`@sales.test.com'):
  assert_app_dependency(app, `AnalyticsLog', `1.0')
else:
  assert_app_dependency(app, `GenericLog', `1.0')
\end{lstlisting}
}
\vspace{0.05in} 

The example below shows a policy that mandates 
that all HTTP GET operations exposed by APIs must support
paging. APIs that do so define two input parameters 
named ``start'' and ``count'' to the GET call.

\vspace{0.05in}
{\footnotesize
\begin{lstlisting}[language=Python, frame=single, showstringspaces=false]
for api in app.api_list:
  get = filter(lambda op : op.method == `GET',  
    api.operations)
  for op in get:
    param_names = map(lambda p : p.name, 
      op.parameters)
    assert_true(`start' in param_names and 
      `count' in param_names)
\end{lstlisting}
}
\vspace{0.05in}

This policy accesses the metadata of API operations that 
is available in the API descriptions.
Since API descriptions can be auto-generated 
from the source code of the APIs, this policy indirectly
references information pertaining to the actual API implementations.

Finally, we present an example for the POST method.  The 
policy below mandates 
that all POST operations exposed by an API are secured 
with OAuth version 2.0.

\vspace{0.05in}
{\footnotesize
\begin{lstlisting}[language=Python, frame=single, showstringspaces=false]
for api in app.api_list:
  post = filter(lambda op : op.method == `POST', 
  	api.operations)
  for op in post:
    assert_true(op.authorizations.get(`oauth2'))
\end{lstlisting}
}
\vspace{0.05in}

EAGER places no restrictions on how many policy files are specified by 
administrators. Applications are validated against each policy file. Failure
of any assertion in any policy file will cause the ADC to abort 
application deployment. Once an application has been checked against all
applicable policies, ADC persists the latest application and API metadata into
the Metadata Manager.  At this point, the ADC may report success to the user
and proceed with application deployment. In a PaaS setting
this deployment activity typically involves three steps:

\begin{enumerate}
\vspace{0.05in}
\item Deploy the application in the cloud application run-time (application server).
\vspace{0.05in}
\item Publish the APIs enclosed in the application and their specifications to
the API Discovery Portal or catalog.
\vspace{0.05in}
\item Publish the APIs enclosed in the application to an API Gateway server.
\vspace{0.05in}
\end{enumerate}

Step $1$ is required to complete the application deployment in the cloud even
without EAGER. We explain the significance of steps $2$ and $3$ in the 
following subsections.

\subsubsection{API Discovery Portal} 
The API Discovery Portal (ADP) is an online
catalog where developers can browse available web APIs. Whenever the ADC
approves and deploys a new application, it registers all the APIs exported by
the application in ADP.  EAGER mandates that any developer interested in using
an API, first subscribe to that API and obtain the proper credentials (API
keys) from the ADP. The API keys issued by the ADP can consist of an
OAuth~\cite{oauth2}
access
token (as is typical of many commercial REST-based web services) 
or a similar authorization credential, which can be used to identify the
developer/application that is invoking the API. This credential management
identification process is used for auditing and run-time governance in EAGER.

The API keys issued by the ADP are stored in the Metadata Manager. When a
programmer develops a new application using one or more API dependencies, we
can require the developer to declare its dependencies along with the API
keys obtained from the ADP. The ADC verifies this information against
the Metadata Manager as a part of its dependency check and ensures that the
declared dependencies are correct and the specified API keys are valid. 

Deployment-time governance policies
may further incentivize the declaration of API 
dependencies explicitly by making it 
impossible to call an API without first declaring it as a dependency along
with the proper API keys. These types of policies can be implemented
with minor changes to the
application run-time in the cloud so that it loads the API credentials from
the dependency declaration provided by the application developer.

In addition to API discovery, the ADP also provides a user
interface for API authors to select their own APIs and deprecate them or
retire them. Deprecated APIs will be removed from the API search
results of the portal, and application developers will no longer be able to 
subscribe to them. However, already existing subscriptions and API keys will continue
to work until the API is eventually retired. 
The deprecation is considered a courtesy notice for application developers
who have developed applications using the API, to migrate their code to a newer and active version
if the API. 
Once retired, any applications that have
not still been migrated to the latest version of the API will cease to operate.

\subsubsection{API Gateway} 
Run-time governance of web services by systems such as
Synapse~\cite{synapse} make use of an API ``proxy'' or gateway.
The EAGER API Gateway does so to intercept API calls and validate 
the API keys contained within them.
EAGER intercepts requests by blocking direct access to the APIs in the
application run-time (app servers), and publishing the API Gateway address as
the API endpoint in the ADP. We do so via firewall rules
or router configuration that prevents the cloud app servers from receiving any
API traffic from a source other than the API Gateway. Once the API Gateway validates
an API call, it routes the message to the
application server in the cloud platform that hosts the API.

The API Gateway can be implemented via one or more (load-balanced) servers.
In addition to API key validation, the API Gateway performs other
functions such as monitoring, throttling (rate limiting), SLA
enforcement, and run-time policy validation. 
