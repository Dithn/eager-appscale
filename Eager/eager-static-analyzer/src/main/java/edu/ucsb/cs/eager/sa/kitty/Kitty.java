/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  "License"); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package edu.ucsb.cs.eager.sa.kitty;

import edu.ucsb.cs.eager.sa.cerebro.CFGAnalyzer;
import edu.ucsb.cs.eager.sa.cerebro.Cerebro;
import edu.ucsb.cs.eager.sa.kitty.qbets.*;
import edu.ucsb.cs.eager.sa.kitty.simulation.SimulationBasedPredictor;
import soot.SootMethod;

import java.io.*;
import java.util.*;

/**
 * Kitty analyzes trace files generated by Cerebro and makes
 * predictions regarding the timing of the function calls. It picks
 * the worst-case paths from Cerebro traces and predicts their
 * execution time. Kitty is named after Kitty Pryde, for her ability of
 * phasing through the currents of time.
 */
public class Kitty {

    public static void main(String[] args) throws IOException {
        PredictionConfigMaker configMaker = new PredictionConfigMaker();
        PredictionConfig config;
        try {
            config = configMaker.construct(args, "Kitty");
        } catch (PredictionConfigException e) {
            System.err.println(e.getMessage());
            return;
        }

        Kitty k = new Kitty();
        long start = System.currentTimeMillis();
        Collection<MethodInfo> methods = k.getMethods(config);
        k.run(config, methods);
        long end = System.currentTimeMillis();
        System.out.println("\nTime elapsed: " + (end - start)/1000.0 + " seconds");
    }

    public Collection<MethodInfo> getMethods(PredictionConfig config) throws IOException {
        Collection<MethodInfo> allMethods;
        if (config.getTraceFile() != null) {
            TraceLogParser parser = new TraceLogParser();
            parser.parseFile(config.getTraceFile());
            allMethods = parser.getMethods();
        } else {
            allMethods = getMethodsFromCerebro(config);
        }

        List<MethodInfo> methods = new ArrayList<>();
        for (MethodInfo m : allMethods) {
            if (config.isEnabledMethod(m.getName())) {
                methods.add(m);
            }
        }
        return methods;
    }

    public static PathResult makePredictions(PredictionConfig config,
                                             long start, long end) throws IOException {
        config.getQbetsConfig().setStart(start);
        config.getQbetsConfig().setEnd(end);
        config.setHideOutput(true);

        Kitty kitty = new Kitty();
        Collection<MethodInfo> methods = kitty.getMethods(config);
        MethodInfo method = null;
        for (MethodInfo m : methods) {
            if (config.isEnabledMethod(m.getName())) {
                method = m;
                break;
            }
        }
        if (method == null) {
            return null;
        }

        QBETSTracingPredictionOutput output = (QBETSTracingPredictionOutput) kitty.run(config, methods);
        return output.get(method).findLargest();
    }

    public PredictionOutput run(PredictionConfig config,
                                Collection<MethodInfo> methods) throws IOException {
        Predictor predictor;
        if (config.getSimulationConfig() != null) {
            predictor = new SimulationBasedPredictor(config.getSimulationConfig());
        } else if (config.getQbetsConfig() != null) {
            if (config.isSimplePredictor()) {
                predictor = new SimpleQBETSPredictor(config.getQbetsConfig());
            } else {
                predictor = new QBETSTracingPredictor(config.getQbetsConfig());
            }
        } else {
            throw new IllegalArgumentException();
        }

        PredictionOutput output = predictor.run(methods);
        if (output != null && !config.isHideOutput()) {
            output.write(System.out);
        }
        return output;
    }

    private Collection<MethodInfo> getMethodsFromCerebro(PredictionConfig config) {
        Cerebro cerebro = new Cerebro(config.getCerebroClasspath(), config.getClazz());
        cerebro.setLoadNecessaryClasses(config.isLoadNecessaryClasses());
        cerebro.setWholeProgramMode(config.isWholeProgramMode());
        try {
            Map<SootMethod,CFGAnalyzer> results = cerebro.analyze();
            Set<MethodInfo> methods = new TreeSet<>(new MethodInfo.MethodInfoComparator());
            for (Map.Entry<SootMethod,CFGAnalyzer> entry : results.entrySet()) {
                MethodInfo mi = new MethodInfo(entry.getKey().getName());
                for (List<SootMethod> path : entry.getValue().getPaths()) {
                    Path callPath = new Path();
                    for (SootMethod sm : path) {
                        String name = sm.getDeclaringClass().getName() + "#" + sm.getName() + "()";
                        if (config.isExcludedAPI(name)) {
                            continue;
                        }

                        APICall call = new APICall(name);
                        if (call.isLoop()) {
                            // Use the same entity count limit for all loops for now.
                            call.setIterations(config.getMaxEntities());
                        }
                        callPath.add(call);
                    }
                    mi.addPath(callPath);
                }
                methods.add(mi);
            }
            return methods;
        } finally {
            cerebro.cleanup();
        }
    }

}
