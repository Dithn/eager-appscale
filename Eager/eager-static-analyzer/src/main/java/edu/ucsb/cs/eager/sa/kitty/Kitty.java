/*
 *  Licensed to the Apache Software Foundation (ASF) under one
 *  or more contributor license agreements.  See the NOTICE file
 *  distributed with this work for additional information
 *  regarding copyright ownership.  The ASF licenses this file
 *  to you under the Apache License, Version 2.0 (the
 *  "License"); you may not use this file except in compliance
 *  with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package edu.ucsb.cs.eager.sa.kitty;

import edu.ucsb.cs.eager.sa.cerebro.CFGAnalyzer;
import edu.ucsb.cs.eager.sa.cerebro.Cerebro;
import edu.ucsb.cs.eager.sa.kitty.qbets.*;
import edu.ucsb.cs.eager.sa.kitty.simulation.SimulationBasedPredictor;
import soot.SootMethod;

import java.io.*;
import java.util.*;

/**
 * Kitty analyzes trace files generated by Cerebro and makes
 * predictions regarding the timing of the function calls. It picks
 * the worst-case paths from Cerebro traces and predicts their
 * execution time. Kitty is named after Kitty Pryde, for her ability of
 * phasing through the currents of time.
 */
public class Kitty {

    public static void main(String[] args) throws IOException {
        ConfigMaker configMaker = new ConfigMaker();
        Config config;
        try {
            config = configMaker.construct(args, "Kitty");
        } catch (ConfigException e) {
            System.err.println(e.getMessage());
            return;
        }

        Kitty k = new Kitty();
        long start = System.currentTimeMillis();
        Collection<MethodInfo> methods = k.getMethods(config);
        k.run(config, methods);
        long end = System.currentTimeMillis();
        System.out.println("\nTime elapsed: " + (end - start)/1000.0 + " seconds");
    }

    public Collection<MethodInfo> getMethods(Config config) throws IOException {
        Collection<MethodInfo> allMethods;
        if (config.getTraceFile() != null) {
            TraceLogParser parser = new TraceLogParser();
            parser.parseFile(config.getTraceFile());
            allMethods = parser.getMethods();
        } else {
            allMethods = getMethodsFromCerebro(config);
        }

        List<MethodInfo> methods = new ArrayList<>();
        for (MethodInfo m : allMethods) {
            if (config.isEnabledMethod(m.getName())) {
                methods.add(m);
            }
        }
        return methods;
    }

    /**
     * Make SLA predictions for the specified time frame using the given
     * Config instance. Disable approach1 predictions (for performance
     * reasons), and also the console output while performing the
     * analysis. This method assumes that the Config instance is
     * populated with just a single method. Once the predictions are made,
     * it will return the prediction trace for the most expensive path
     * in that method.
     *
     * @param config A Config instance with a single method configuration
     * @param start starting timestamp
     * @param end ending timestamp
     * @return A PathResult instance corresponding to the most expensive path in the method
     * @throws IOException on error
     */
    public static PathResult makePredictions(Config config, long start,
                                             long end) throws IOException {
        config.getQbetsConfig().setStart(start);
        config.getQbetsConfig().setEnd(end);
        config.getQbetsConfig().setDisableApproach1(true);
        config.setHideOutput(true);

        Kitty kitty = new Kitty();
        Collection<MethodInfo> methods = kitty.getMethods(config);
        MethodInfo method = null;
        for (MethodInfo m : methods) {
            if (config.isEnabledMethod(m.getName())) {
                method = m;
                break;
            }
        }
        if (method == null) {
            return null;
        }

        QBETSTracingPredictionOutput output =
                (QBETSTracingPredictionOutput) kitty.run(config, methods);
        return output.get(method).findLargest();
    }

    public PredictionOutput run(Config config, Collection<MethodInfo> methods) throws IOException {
        Predictor predictor;
        if (config.getSimulationConfig() != null) {
            predictor = new SimulationBasedPredictor(config.getSimulationConfig());
        } else if (config.getQbetsConfig() != null) {
            if (config.isSimplePredictor()) {
                predictor = new SimpleQBETSPredictor(config.getQbetsConfig());
            } else {
                predictor = new QBETSTracingPredictor(config.getQbetsConfig());
            }
        } else {
            throw new IllegalArgumentException();
        }

        PredictionOutput output = predictor.run(methods);
        if (output != null && !config.isHideOutput()) {
            output.write(System.out);
        }
        return output;
    }

    private Collection<MethodInfo> getMethodsFromCerebro(Config config) {
        Cerebro cerebro = new Cerebro(config.getCerebroClasspath(), config.getClazz());
        cerebro.setLoadNecessaryClasses(config.isLoadNecessaryClasses());
        cerebro.setWholeProgramMode(config.isWholeProgramMode());
        try {
            Map<SootMethod,CFGAnalyzer> results = cerebro.analyze();
            Set<MethodInfo> methods = new TreeSet<>(new MethodInfo.MethodInfoComparator());
            for (Map.Entry<SootMethod,CFGAnalyzer> entry : results.entrySet()) {
                methods.add(processMethod(config, entry.getKey().getName(),
                        entry.getValue().getPaths())) ;
            }
            return methods;
        } finally {
            cerebro.cleanup();
        }
    }

    private MethodInfo processMethod(Config config, String methodName,
                                     Collection<List<SootMethod>> paths) {
        MethodInfo mi = new MethodInfo(methodName);
        for (List<SootMethod> path : paths) {
            Path callPath = new Path();
            for (SootMethod sm : path) {
                String name = sm.getDeclaringClass().getName() + "#" + sm.getName() + "()";
                if (config.isExcludedAPI(name)) {
                    continue;
                }

                APICall call = new APICall(name);
                if (call.isLoop()) {
                    // Use the same entity count limit for all loops for now.
                    call.setIterations(config.getMaxEntities());
                }
                callPath.add(call);
            }
            mi.addPath(callPath);
        }
        return mi;
    }

}
